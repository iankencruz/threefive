// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
  url, thumbnail_url, medium_url, type, title, alt_text, mime_type, file_size, sort_order
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, url, thumbnail_url, type, is_public, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at, medium_url
`

type CreateMediaParams struct {
	Url          string  `db:"url" json:"url"`
	ThumbnailUrl *string `db:"thumbnail_url" json:"thumbnail_url"`
	MediumUrl    *string `db:"medium_url" json:"medium_url"`
	Type         string  `db:"type" json:"type"`
	Title        *string `db:"title" json:"title"`
	AltText      *string `db:"alt_text" json:"alt_text"`
	MimeType     *string `db:"mime_type" json:"mime_type"`
	FileSize     *int32  `db:"file_size" json:"file_size"`
	SortOrder    int32   `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Media, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.Url,
		arg.ThumbnailUrl,
		arg.MediumUrl,
		arg.Type,
		arg.Title,
		arg.AltText,
		arg.MimeType,
		arg.FileSize,
		arg.SortOrder,
	)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.ThumbnailUrl,
		&i.Type,
		&i.IsPublic,
		&i.Title,
		&i.AltText,
		&i.MimeType,
		&i.FileSize,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MediumUrl,
	)
	return i, err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media WHERE id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMedia, id)
	return err
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT id, url, thumbnail_url, type, is_public, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at, medium_url FROM media WHERE id = $1
`

func (q *Queries) GetMediaByID(ctx context.Context, id pgtype.UUID) (Media, error) {
	row := q.db.QueryRow(ctx, getMediaByID, id)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.ThumbnailUrl,
		&i.Type,
		&i.IsPublic,
		&i.Title,
		&i.AltText,
		&i.MimeType,
		&i.FileSize,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MediumUrl,
	)
	return i, err
}

const listMedia = `-- name: ListMedia :many
SELECT id, url, thumbnail_url, type, is_public, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at, medium_url FROM media ORDER BY sort_order ASC
`

func (q *Queries) ListMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.Query(ctx, listMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.ThumbnailUrl,
			&i.Type,
			&i.IsPublic,
			&i.Title,
			&i.AltText,
			&i.MimeType,
			&i.FileSize,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MediumUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaPaginated = `-- name: ListMediaPaginated :many
SELECT id, url, thumbnail_url, type, is_public, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at, medium_url FROM media
ORDER BY sort_order ASC
LIMIT $1 OFFSET $2
`

type ListMediaPaginatedParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListMediaPaginated(ctx context.Context, arg ListMediaPaginatedParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, listMediaPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.ThumbnailUrl,
			&i.Type,
			&i.IsPublic,
			&i.Title,
			&i.AltText,
			&i.MimeType,
			&i.FileSize,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MediumUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicMedia = `-- name: ListPublicMedia :many
SELECT id, url, thumbnail_url, type, is_public, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at, medium_url FROM media
WHERE is_public = true
ORDER BY sort_order ASC
`

func (q *Queries) ListPublicMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.Query(ctx, listPublicMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.ThumbnailUrl,
			&i.Type,
			&i.IsPublic,
			&i.Title,
			&i.AltText,
			&i.MimeType,
			&i.FileSize,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MediumUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMediaSortOrder = `-- name: UpdateMediaSortOrder :exec
UPDATE media SET sort_order = $1 WHERE id = $2
`

type UpdateMediaSortOrderParams struct {
	SortOrder int32       `db:"sort_order" json:"sort_order"`
	ID        pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateMediaSortOrder(ctx context.Context, arg UpdateMediaSortOrderParams) error {
	_, err := q.db.Exec(ctx, updateMediaSortOrder, arg.SortOrder, arg.ID)
	return err
}
