// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: page_metadata.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBlogData = `-- name: CreateBlogData :one

INSERT INTO page_blog_data (
    page_id,
    excerpt,
    reading_time,
    is_featured
)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, page_id, excerpt, reading_time, is_featured, created_at, updated_at
`

type CreateBlogDataParams struct {
	PageID      uuid.UUID   `json:"page_id"`
	Excerpt     pgtype.Text `json:"excerpt"`
	ReadingTime pgtype.Int4 `json:"reading_time"`
	IsFeatured  pgtype.Bool `json:"is_featured"`
}

// ============================================
// Blog Data Queries
// ============================================
func (q *Queries) CreateBlogData(ctx context.Context, arg CreateBlogDataParams) (PageBlogData, error) {
	row := q.db.QueryRow(ctx, createBlogData,
		arg.PageID,
		arg.Excerpt,
		arg.ReadingTime,
		arg.IsFeatured,
	)
	var i PageBlogData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Excerpt,
		&i.ReadingTime,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPageSEO = `-- name: CreatePageSEO :one


INSERT INTO page_seo (
    page_id,
    meta_title,
    meta_description,
    og_title,
    og_description,
    og_image_id,
    canonical_url,
    robots_index,
    robots_follow
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
RETURNING id, page_id, meta_title, meta_description, og_title, og_description, og_image_id, canonical_url, robots_index, robots_follow, created_at, updated_at
`

type CreatePageSEOParams struct {
	PageID          uuid.UUID   `json:"page_id"`
	MetaTitle       pgtype.Text `json:"meta_title"`
	MetaDescription pgtype.Text `json:"meta_description"`
	OgTitle         pgtype.Text `json:"og_title"`
	OgDescription   pgtype.Text `json:"og_description"`
	OgImageID       pgtype.UUID `json:"og_image_id"`
	CanonicalUrl    pgtype.Text `json:"canonical_url"`
	RobotsIndex     pgtype.Bool `json:"robots_index"`
	RobotsFollow    pgtype.Bool `json:"robots_follow"`
}

// backend/sql/queries/page_metadata.sql
// ============================================
// Page SEO Queries
// ============================================
func (q *Queries) CreatePageSEO(ctx context.Context, arg CreatePageSEOParams) (PageSeo, error) {
	row := q.db.QueryRow(ctx, createPageSEO,
		arg.PageID,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.OgTitle,
		arg.OgDescription,
		arg.OgImageID,
		arg.CanonicalUrl,
		arg.RobotsIndex,
		arg.RobotsFollow,
	)
	var i PageSeo
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgTitle,
		&i.OgDescription,
		&i.OgImageID,
		&i.CanonicalUrl,
		&i.RobotsIndex,
		&i.RobotsFollow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectData = `-- name: CreateProjectData :one

INSERT INTO page_project_data (
    page_id,
    client_name,
    project_year,
    project_url,
    technologies,
    project_status
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING id, page_id, client_name, project_year, project_url, technologies, project_status, created_at, updated_at
`

type CreateProjectDataParams struct {
	PageID        uuid.UUID   `json:"page_id"`
	ClientName    pgtype.Text `json:"client_name"`
	ProjectYear   pgtype.Int4 `json:"project_year"`
	ProjectUrl    pgtype.Text `json:"project_url"`
	Technologies  []byte      `json:"technologies"`
	ProjectStatus pgtype.Text `json:"project_status"`
}

// ============================================
// Project Data Queries
// ============================================
func (q *Queries) CreateProjectData(ctx context.Context, arg CreateProjectDataParams) (PageProjectData, error) {
	row := q.db.QueryRow(ctx, createProjectData,
		arg.PageID,
		arg.ClientName,
		arg.ProjectYear,
		arg.ProjectUrl,
		arg.Technologies,
		arg.ProjectStatus,
	)
	var i PageProjectData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.Technologies,
		&i.ProjectStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBlogData = `-- name: DeleteBlogData :exec
DELETE FROM page_blog_data WHERE page_id = $1
`

func (q *Queries) DeleteBlogData(ctx context.Context, pageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlogData, pageID)
	return err
}

const deletePageSEO = `-- name: DeletePageSEO :exec
DELETE FROM page_seo WHERE page_id = $1
`

func (q *Queries) DeletePageSEO(ctx context.Context, pageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePageSEO, pageID)
	return err
}

const deleteProjectData = `-- name: DeleteProjectData :exec
DELETE FROM page_project_data WHERE page_id = $1
`

func (q *Queries) DeleteProjectData(ctx context.Context, pageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProjectData, pageID)
	return err
}

const getBlogData = `-- name: GetBlogData :one
SELECT id, page_id, excerpt, reading_time, is_featured, created_at, updated_at FROM page_blog_data
WHERE page_id = $1
`

func (q *Queries) GetBlogData(ctx context.Context, pageID uuid.UUID) (PageBlogData, error) {
	row := q.db.QueryRow(ctx, getBlogData, pageID)
	var i PageBlogData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Excerpt,
		&i.ReadingTime,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPageSEO = `-- name: GetPageSEO :one
SELECT id, page_id, meta_title, meta_description, og_title, og_description, og_image_id, canonical_url, robots_index, robots_follow, created_at, updated_at FROM page_seo
WHERE page_id = $1
`

func (q *Queries) GetPageSEO(ctx context.Context, pageID uuid.UUID) (PageSeo, error) {
	row := q.db.QueryRow(ctx, getPageSEO, pageID)
	var i PageSeo
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgTitle,
		&i.OgDescription,
		&i.OgImageID,
		&i.CanonicalUrl,
		&i.RobotsIndex,
		&i.RobotsFollow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectData = `-- name: GetProjectData :one
SELECT id, page_id, client_name, project_year, project_url, technologies, project_status, created_at, updated_at FROM page_project_data
WHERE page_id = $1
`

func (q *Queries) GetProjectData(ctx context.Context, pageID uuid.UUID) (PageProjectData, error) {
	row := q.db.QueryRow(ctx, getProjectData, pageID)
	var i PageProjectData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.Technologies,
		&i.ProjectStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBlogPages = `-- name: ListBlogPages :many
SELECT p.id, p.title, p.slug, p.page_type, p.status, p.featured_image_id, p.author_id, p.created_at, p.updated_at, p.published_at, p.deleted_at, pbd.id, pbd.page_id, pbd.excerpt, pbd.reading_time, pbd.is_featured, pbd.created_at, pbd.updated_at
FROM pages p
INNER JOIN page_blog_data pbd ON pbd.page_id = p.id
WHERE p.status = 'published' AND p.deleted_at IS NULL
ORDER BY p.published_at DESC
LIMIT $2 OFFSET $1
`

type ListBlogPagesParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

type ListBlogPagesRow struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	PageType        PageType           `json:"page_type"`
	Status          NullPageStatus     `json:"status"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	AuthorID        uuid.UUID          `json:"author_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	ID_2            uuid.UUID          `json:"id_2"`
	PageID          uuid.UUID          `json:"page_id"`
	Excerpt         pgtype.Text        `json:"excerpt"`
	ReadingTime     pgtype.Int4        `json:"reading_time"`
	IsFeatured      pgtype.Bool        `json:"is_featured"`
	CreatedAt_2     time.Time          `json:"created_at_2"`
	UpdatedAt_2     time.Time          `json:"updated_at_2"`
}

func (q *Queries) ListBlogPages(ctx context.Context, arg ListBlogPagesParams) ([]ListBlogPagesRow, error) {
	rows, err := q.db.Query(ctx, listBlogPages, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBlogPagesRow
	for rows.Next() {
		var i ListBlogPagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.PageType,
			&i.Status,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.PageID,
			&i.Excerpt,
			&i.ReadingTime,
			&i.IsFeatured,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedBlogPages = `-- name: ListFeaturedBlogPages :many
SELECT p.id, p.title, p.slug, p.page_type, p.status, p.featured_image_id, p.author_id, p.created_at, p.updated_at, p.published_at, p.deleted_at, pbd.id, pbd.page_id, pbd.excerpt, pbd.reading_time, pbd.is_featured, pbd.created_at, pbd.updated_at
FROM pages p
INNER JOIN page_blog_data pbd ON pbd.page_id = p.id
WHERE p.status = 'published' 
  AND p.deleted_at IS NULL
  AND pbd.is_featured = true
ORDER BY p.published_at DESC
LIMIT $1
`

type ListFeaturedBlogPagesRow struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	PageType        PageType           `json:"page_type"`
	Status          NullPageStatus     `json:"status"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	AuthorID        uuid.UUID          `json:"author_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	ID_2            uuid.UUID          `json:"id_2"`
	PageID          uuid.UUID          `json:"page_id"`
	Excerpt         pgtype.Text        `json:"excerpt"`
	ReadingTime     pgtype.Int4        `json:"reading_time"`
	IsFeatured      pgtype.Bool        `json:"is_featured"`
	CreatedAt_2     time.Time          `json:"created_at_2"`
	UpdatedAt_2     time.Time          `json:"updated_at_2"`
}

func (q *Queries) ListFeaturedBlogPages(ctx context.Context, limitVal int32) ([]ListFeaturedBlogPagesRow, error) {
	rows, err := q.db.Query(ctx, listFeaturedBlogPages, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturedBlogPagesRow
	for rows.Next() {
		var i ListFeaturedBlogPagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.PageType,
			&i.Status,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.PageID,
			&i.Excerpt,
			&i.ReadingTime,
			&i.IsFeatured,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectPages = `-- name: ListProjectPages :many
SELECT p.id, p.title, p.slug, p.page_type, p.status, p.featured_image_id, p.author_id, p.created_at, p.updated_at, p.published_at, p.deleted_at, ppd.id, ppd.page_id, ppd.client_name, ppd.project_year, ppd.project_url, ppd.technologies, ppd.project_status, ppd.created_at, ppd.updated_at
FROM pages p
INNER JOIN page_project_data ppd ON ppd.page_id = p.id
WHERE p.status = 'published' AND p.deleted_at IS NULL
ORDER BY ppd.project_year DESC, p.published_at DESC
LIMIT $2 OFFSET $1
`

type ListProjectPagesParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

type ListProjectPagesRow struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	PageType        PageType           `json:"page_type"`
	Status          NullPageStatus     `json:"status"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	AuthorID        uuid.UUID          `json:"author_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	ID_2            uuid.UUID          `json:"id_2"`
	PageID          uuid.UUID          `json:"page_id"`
	ClientName      pgtype.Text        `json:"client_name"`
	ProjectYear     pgtype.Int4        `json:"project_year"`
	ProjectUrl      pgtype.Text        `json:"project_url"`
	Technologies    []byte             `json:"technologies"`
	ProjectStatus   pgtype.Text        `json:"project_status"`
	CreatedAt_2     time.Time          `json:"created_at_2"`
	UpdatedAt_2     time.Time          `json:"updated_at_2"`
}

func (q *Queries) ListProjectPages(ctx context.Context, arg ListProjectPagesParams) ([]ListProjectPagesRow, error) {
	rows, err := q.db.Query(ctx, listProjectPages, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectPagesRow
	for rows.Next() {
		var i ListProjectPagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.PageType,
			&i.Status,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.PageID,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.Technologies,
			&i.ProjectStatus,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlogData = `-- name: UpdateBlogData :one
UPDATE page_blog_data
SET 
    excerpt = $1,
    reading_time = $2,
    is_featured = $3,
    updated_at = NOW()
WHERE page_id = $4
RETURNING id, page_id, excerpt, reading_time, is_featured, created_at, updated_at
`

type UpdateBlogDataParams struct {
	Excerpt     pgtype.Text `json:"excerpt"`
	ReadingTime pgtype.Int4 `json:"reading_time"`
	IsFeatured  pgtype.Bool `json:"is_featured"`
	PageID      uuid.UUID   `json:"page_id"`
}

func (q *Queries) UpdateBlogData(ctx context.Context, arg UpdateBlogDataParams) (PageBlogData, error) {
	row := q.db.QueryRow(ctx, updateBlogData,
		arg.Excerpt,
		arg.ReadingTime,
		arg.IsFeatured,
		arg.PageID,
	)
	var i PageBlogData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Excerpt,
		&i.ReadingTime,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePageSEO = `-- name: UpdatePageSEO :one
UPDATE page_seo
SET 
    meta_title = $1,
    meta_description = $2,
    og_title = $3,
    og_description = $4,
    og_image_id = $5,
    canonical_url = $6,
    robots_index = $7,
    robots_follow = $8,
    updated_at = NOW()
WHERE page_id = $9
RETURNING id, page_id, meta_title, meta_description, og_title, og_description, og_image_id, canonical_url, robots_index, robots_follow, created_at, updated_at
`

type UpdatePageSEOParams struct {
	MetaTitle       pgtype.Text `json:"meta_title"`
	MetaDescription pgtype.Text `json:"meta_description"`
	OgTitle         pgtype.Text `json:"og_title"`
	OgDescription   pgtype.Text `json:"og_description"`
	OgImageID       pgtype.UUID `json:"og_image_id"`
	CanonicalUrl    pgtype.Text `json:"canonical_url"`
	RobotsIndex     pgtype.Bool `json:"robots_index"`
	RobotsFollow    pgtype.Bool `json:"robots_follow"`
	PageID          uuid.UUID   `json:"page_id"`
}

func (q *Queries) UpdatePageSEO(ctx context.Context, arg UpdatePageSEOParams) (PageSeo, error) {
	row := q.db.QueryRow(ctx, updatePageSEO,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.OgTitle,
		arg.OgDescription,
		arg.OgImageID,
		arg.CanonicalUrl,
		arg.RobotsIndex,
		arg.RobotsFollow,
		arg.PageID,
	)
	var i PageSeo
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgTitle,
		&i.OgDescription,
		&i.OgImageID,
		&i.CanonicalUrl,
		&i.RobotsIndex,
		&i.RobotsFollow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectData = `-- name: UpdateProjectData :one
UPDATE page_project_data
SET 
    client_name = $1,
    project_year = $2,
    project_url = $3,
    technologies = $4,
    project_status = $5,
    updated_at = NOW()
WHERE page_id = $6
RETURNING id, page_id, client_name, project_year, project_url, technologies, project_status, created_at, updated_at
`

type UpdateProjectDataParams struct {
	ClientName    pgtype.Text `json:"client_name"`
	ProjectYear   pgtype.Int4 `json:"project_year"`
	ProjectUrl    pgtype.Text `json:"project_url"`
	Technologies  []byte      `json:"technologies"`
	ProjectStatus pgtype.Text `json:"project_status"`
	PageID        uuid.UUID   `json:"page_id"`
}

func (q *Queries) UpdateProjectData(ctx context.Context, arg UpdateProjectDataParams) (PageProjectData, error) {
	row := q.db.QueryRow(ctx, updateProjectData,
		arg.ClientName,
		arg.ProjectYear,
		arg.ProjectUrl,
		arg.Technologies,
		arg.ProjectStatus,
		arg.PageID,
	)
	var i PageProjectData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.Technologies,
		&i.ProjectStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertBlogData = `-- name: UpsertBlogData :one
INSERT INTO page_blog_data (
    page_id,
    excerpt,
    reading_time,
    is_featured
)
VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (page_id) 
DO UPDATE SET
    excerpt = EXCLUDED.excerpt,
    reading_time = EXCLUDED.reading_time,
    is_featured = EXCLUDED.is_featured,
    updated_at = NOW()
RETURNING id, page_id, excerpt, reading_time, is_featured, created_at, updated_at
`

type UpsertBlogDataParams struct {
	PageID      uuid.UUID   `json:"page_id"`
	Excerpt     pgtype.Text `json:"excerpt"`
	ReadingTime pgtype.Int4 `json:"reading_time"`
	IsFeatured  pgtype.Bool `json:"is_featured"`
}

func (q *Queries) UpsertBlogData(ctx context.Context, arg UpsertBlogDataParams) (PageBlogData, error) {
	row := q.db.QueryRow(ctx, upsertBlogData,
		arg.PageID,
		arg.Excerpt,
		arg.ReadingTime,
		arg.IsFeatured,
	)
	var i PageBlogData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Excerpt,
		&i.ReadingTime,
		&i.IsFeatured,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPageSEO = `-- name: UpsertPageSEO :one
INSERT INTO page_seo (
    page_id,
    meta_title,
    meta_description,
    og_title,
    og_description,
    og_image_id,
    canonical_url,
    robots_index,
    robots_follow
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
ON CONFLICT (page_id) 
DO UPDATE SET
    meta_title = EXCLUDED.meta_title,
    meta_description = EXCLUDED.meta_description,
    og_title = EXCLUDED.og_title,
    og_description = EXCLUDED.og_description,
    og_image_id = EXCLUDED.og_image_id,
    canonical_url = EXCLUDED.canonical_url,
    robots_index = EXCLUDED.robots_index,
    robots_follow = EXCLUDED.robots_follow,
    updated_at = NOW()
RETURNING id, page_id, meta_title, meta_description, og_title, og_description, og_image_id, canonical_url, robots_index, robots_follow, created_at, updated_at
`

type UpsertPageSEOParams struct {
	PageID          uuid.UUID   `json:"page_id"`
	MetaTitle       pgtype.Text `json:"meta_title"`
	MetaDescription pgtype.Text `json:"meta_description"`
	OgTitle         pgtype.Text `json:"og_title"`
	OgDescription   pgtype.Text `json:"og_description"`
	OgImageID       pgtype.UUID `json:"og_image_id"`
	CanonicalUrl    pgtype.Text `json:"canonical_url"`
	RobotsIndex     pgtype.Bool `json:"robots_index"`
	RobotsFollow    pgtype.Bool `json:"robots_follow"`
}

func (q *Queries) UpsertPageSEO(ctx context.Context, arg UpsertPageSEOParams) (PageSeo, error) {
	row := q.db.QueryRow(ctx, upsertPageSEO,
		arg.PageID,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.OgTitle,
		arg.OgDescription,
		arg.OgImageID,
		arg.CanonicalUrl,
		arg.RobotsIndex,
		arg.RobotsFollow,
	)
	var i PageSeo
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgTitle,
		&i.OgDescription,
		&i.OgImageID,
		&i.CanonicalUrl,
		&i.RobotsIndex,
		&i.RobotsFollow,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProjectData = `-- name: UpsertProjectData :one
INSERT INTO page_project_data (
    page_id,
    client_name,
    project_year,
    project_url,
    technologies,
    project_status
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
ON CONFLICT (page_id) 
DO UPDATE SET
    client_name = EXCLUDED.client_name,
    project_year = EXCLUDED.project_year,
    project_url = EXCLUDED.project_url,
    technologies = EXCLUDED.technologies,
    project_status = EXCLUDED.project_status,
    updated_at = NOW()
RETURNING id, page_id, client_name, project_year, project_url, technologies, project_status, created_at, updated_at
`

type UpsertProjectDataParams struct {
	PageID        uuid.UUID   `json:"page_id"`
	ClientName    pgtype.Text `json:"client_name"`
	ProjectYear   pgtype.Int4 `json:"project_year"`
	ProjectUrl    pgtype.Text `json:"project_url"`
	Technologies  []byte      `json:"technologies"`
	ProjectStatus pgtype.Text `json:"project_status"`
}

func (q *Queries) UpsertProjectData(ctx context.Context, arg UpsertProjectDataParams) (PageProjectData, error) {
	row := q.db.QueryRow(ctx, upsertProjectData,
		arg.PageID,
		arg.ClientName,
		arg.ProjectYear,
		arg.ProjectUrl,
		arg.Technologies,
		arg.ProjectStatus,
	)
	var i PageProjectData
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.Technologies,
		&i.ProjectStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
