// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contacts.sql

package sqlc

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupDeletedContacts = `-- name: CleanupDeletedContacts :exec
DELETE FROM contacts
WHERE deleted_at IS NOT NULL
  AND deleted_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupDeletedContacts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupDeletedContacts)
	return err
}

const countContacts = `-- name: CountContacts :one
SELECT COUNT(*) FROM contacts
WHERE deleted_at IS NULL
`

func (q *Queries) CountContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactsByStatus = `-- name: CountContactsByStatus :one
SELECT COUNT(*) FROM contacts
WHERE status = $1 AND deleted_at IS NULL
`

func (q *Queries) CountContactsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countContactsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContact = `-- name: CreateContact :one
INSERT INTO contacts (
    name,
    email,
    subject,
    message,
    ip_address,
    user_agent
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at
`

type CreateContactParams struct {
	Name      string      `json:"name"`
	Email     string      `json:"email"`
	Subject   pgtype.Text `json:"subject"`
	Message   string      `json:"message"`
	IpAddress *netip.Addr `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (Contacts, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.Name,
		arg.Email,
		arg.Subject,
		arg.Message,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Contacts
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Message,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.EmailSent,
		&i.EmailError,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getContactByID = `-- name: GetContactByID :one
SELECT id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at FROM contacts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetContactByID(ctx context.Context, id uuid.UUID) (Contacts, error) {
	row := q.db.QueryRow(ctx, getContactByID, id)
	var i Contacts
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Message,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.EmailSent,
		&i.EmailError,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getContactsByIPAddress = `-- name: GetContactsByIPAddress :many
SELECT id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at FROM contacts
WHERE ip_address = $1
  AND created_at > $2
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetContactsByIPAddressParams struct {
	IpAddress *netip.Addr `json:"ip_address"`
	AfterTime time.Time   `json:"after_time"`
}

func (q *Queries) GetContactsByIPAddress(ctx context.Context, arg GetContactsByIPAddressParams) ([]Contacts, error) {
	rows, err := q.db.Query(ctx, getContactsByIPAddress, arg.IpAddress, arg.AfterTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contacts
	for rows.Next() {
		var i Contacts
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Message,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.EmailSent,
			&i.EmailError,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnsentEmails = `-- name: GetUnsentEmails :many
SELECT id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at FROM contacts
WHERE email_sent = false
  AND deleted_at IS NULL
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetUnsentEmails(ctx context.Context, limitCount int32) ([]Contacts, error) {
	rows, err := q.db.Query(ctx, getUnsentEmails, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contacts
	for rows.Next() {
		var i Contacts
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Message,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.EmailSent,
			&i.EmailError,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteContact = `-- name: HardDeleteContact :exec
DELETE FROM contacts
WHERE id = $1
`

func (q *Queries) HardDeleteContact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteContact, id)
	return err
}

const listContacts = `-- name: ListContacts :many
SELECT id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at FROM contacts
WHERE deleted_at IS NULL
ORDER BY
    CASE WHEN $1 = 'created_at_desc' THEN created_at END DESC,
    CASE WHEN $1 = 'created_at_asc' THEN created_at END ASC
LIMIT $3
OFFSET $2
`

type ListContactsParams struct {
	OrderBy     interface{} `json:"order_by"`
	OffsetCount int32       `json:"offset_count"`
	LimitCount  int32       `json:"limit_count"`
}

func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]Contacts, error) {
	rows, err := q.db.Query(ctx, listContacts, arg.OrderBy, arg.OffsetCount, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contacts
	for rows.Next() {
		var i Contacts
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Message,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.EmailSent,
			&i.EmailError,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactsByStatus = `-- name: ListContactsByStatus :many
SELECT id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at FROM contacts
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type ListContactsByStatusParams struct {
	Status      string `json:"status"`
	OffsetCount int32  `json:"offset_count"`
	LimitCount  int32  `json:"limit_count"`
}

func (q *Queries) ListContactsByStatus(ctx context.Context, arg ListContactsByStatusParams) ([]Contacts, error) {
	rows, err := q.db.Query(ctx, listContactsByStatus, arg.Status, arg.OffsetCount, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contacts
	for rows.Next() {
		var i Contacts
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Subject,
			&i.Message,
			&i.Status,
			&i.IpAddress,
			&i.UserAgent,
			&i.EmailSent,
			&i.EmailError,
			&i.EmailSentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailFailed = `-- name: MarkEmailFailed :exec
UPDATE contacts
SET email_sent = false,
    email_error = $1,
    updated_at = NOW()
WHERE id = $2
`

type MarkEmailFailedParams struct {
	Error pgtype.Text `json:"error"`
	ID    uuid.UUID   `json:"id"`
}

func (q *Queries) MarkEmailFailed(ctx context.Context, arg MarkEmailFailedParams) error {
	_, err := q.db.Exec(ctx, markEmailFailed, arg.Error, arg.ID)
	return err
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE contacts
SET email_sent = true,
    email_sent_at = NOW(),
    email_error = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkEmailSent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markEmailSent, id)
	return err
}

const softDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE contacts
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteContact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteContact, id)
	return err
}

const updateContactStatus = `-- name: UpdateContactStatus :one
UPDATE contacts
SET status = $1, updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, name, email, subject, message, status, ip_address, user_agent, email_sent, email_error, email_sent_at, created_at, updated_at, deleted_at
`

type UpdateContactStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateContactStatus(ctx context.Context, arg UpdateContactStatusParams) (Contacts, error) {
	row := q.db.QueryRow(ctx, updateContactStatus, arg.Status, arg.ID)
	var i Contacts
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Subject,
		&i.Message,
		&i.Status,
		&i.IpAddress,
		&i.UserAgent,
		&i.EmailSent,
		&i.EmailError,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
