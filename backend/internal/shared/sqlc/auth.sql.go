// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package sqlc

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredPasswordResetTokens = `-- name: CleanupExpiredPasswordResetTokens :exec
DELETE FROM password_reset_tokens
WHERE expires_at < NOW() OR is_used = true
`

func (q *Queries) CleanupExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredPasswordResetTokens)
	return err
}

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at < NOW() OR (created_at < NOW() - INTERVAL '30 days')
`

func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token, expires_at, created_at, used_at, is_used
`

type CreatePasswordResetTokenParams struct {
	UserID    uuid.UUID `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetTokens, error) {
	row := q.db.QueryRow(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	var i PasswordResetTokens
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UsedAt,
		&i.IsUsed,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, token, expires_at, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, token, expires_at, created_at, updated_at, ip_address, user_agent, is_active
`

type CreateSessionParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	Token     string      `json:"token"`
	ExpiresAt time.Time   `json:"expires_at"`
	IpAddress *netip.Addr `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
	)
	return i, err
}

const deactivateAllUserSessions = `-- name: DeactivateAllUserSessions :exec
UPDATE sessions
SET is_active = false, updated_at = NOW()
WHERE user_id = $1 AND is_active = true
`

func (q *Queries) DeactivateAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateAllUserSessions, userID)
	return err
}

const deactivateSession = `-- name: DeactivateSession :exec
UPDATE sessions
SET is_active = false, updated_at = NOW()
WHERE token = $1
`

func (q *Queries) DeactivateSession(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deactivateSession, token)
	return err
}

const getActiveSessionsByUserID = `-- name: GetActiveSessionsByUserID :many
SELECT id, user_id, token, expires_at, created_at, updated_at, ip_address, user_agent, is_active FROM sessions
WHERE user_id = $1 AND is_active = true AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) GetActiveSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]Sessions, error) {
	rows, err := q.db.Query(ctx, getActiveSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sessions
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT prt.id, prt.user_id, prt.token, prt.expires_at, prt.created_at, prt.used_at, prt.is_used, u.email, u.first_name, u.last_name
FROM password_reset_tokens prt
JOIN users u ON prt.user_id = u.id
WHERE prt.token = $1 AND prt.is_used = false AND prt.expires_at > NOW()
`

type GetPasswordResetTokenRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt time.Time          `json:"created_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	IsUsed    pgtype.Bool        `json:"is_used"`
	Email     string             `json:"email"`
	FirstName string             `json:"first_name"`
	LastName  string             `json:"last_name"`
}

func (q *Queries) GetPasswordResetToken(ctx context.Context, token string) (GetPasswordResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getPasswordResetToken, token)
	var i GetPasswordResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UsedAt,
		&i.IsUsed,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT s.id, s.user_id, s.token, s.expires_at, s.created_at, s.updated_at, s.ip_address, s.user_agent, s.is_active, u.id as user_id, u.email, u.first_name, u.last_name, u.created_at as user_created_at
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token = $1 AND s.is_active = true AND s.expires_at > NOW()
`

type GetSessionByTokenRow struct {
	ID            uuid.UUID   `json:"id"`
	UserID        uuid.UUID   `json:"user_id"`
	Token         string      `json:"token"`
	ExpiresAt     time.Time   `json:"expires_at"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	IpAddress     *netip.Addr `json:"ip_address"`
	UserAgent     pgtype.Text `json:"user_agent"`
	IsActive      pgtype.Bool `json:"is_active"`
	UserID_2      uuid.UUID   `json:"user_id_2"`
	Email         string      `json:"email"`
	FirstName     string      `json:"first_name"`
	LastName      string      `json:"last_name"`
	UserCreatedAt time.Time   `json:"user_created_at"`
}

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (GetSessionByTokenRow, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, token)
	var i GetSessionByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
		&i.UserID_2,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.UserCreatedAt,
	)
	return i, err
}

const updateSessionExpiry = `-- name: UpdateSessionExpiry :one
UPDATE sessions
SET expires_at = $1, updated_at = NOW()
WHERE token = $2 AND is_active = true
RETURNING id, user_id, token, expires_at, created_at, updated_at, ip_address, user_agent, is_active
`

type UpdateSessionExpiryParams struct {
	ExpiresAt time.Time `json:"expires_at"`
	Token     string    `json:"token"`
}

func (q *Queries) UpdateSessionExpiry(ctx context.Context, arg UpdateSessionExpiryParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, updateSessionExpiry, arg.ExpiresAt, arg.Token)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateUserPasswordParams struct {
	PasswordHash string    `json:"password_hash"`
	UserID       uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.PasswordHash, arg.UserID)
	return err
}

const usePasswordResetToken = `-- name: UsePasswordResetToken :exec
UPDATE password_reset_tokens
SET is_used = true, used_at = NOW()
WHERE token = $1
`

func (q *Queries) UsePasswordResetToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, usePasswordResetToken, token)
	return err
}
