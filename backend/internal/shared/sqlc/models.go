// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type PageStatus string

const (
	PageStatusDraft     PageStatus = "draft"
	PageStatusPublished PageStatus = "published"
	PageStatusArchived  PageStatus = "archived"
)

func (e *PageStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PageStatus(s)
	case string:
		*e = PageStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PageStatus: %T", src)
	}
	return nil
}

type NullPageStatus struct {
	PageStatus PageStatus `json:"page_status"`
	Valid      bool       `json:"valid"` // Valid is true if PageStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPageStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PageStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PageStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPageStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PageStatus), nil
}

type ProjectStatus string

const (
	ProjectStatusCompleted ProjectStatus = "completed"
	ProjectStatusOngoing   ProjectStatus = "ongoing"
	ProjectStatusArchived  ProjectStatus = "archived"
)

func (e *ProjectStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProjectStatus(s)
	case string:
		*e = ProjectStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProjectStatus: %T", src)
	}
	return nil
}

type NullProjectStatus struct {
	ProjectStatus ProjectStatus `json:"project_status"`
	Valid         bool          `json:"valid"` // Valid is true if ProjectStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProjectStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProjectStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProjectStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProjectStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProjectStatus), nil
}

type StorageType string

const (
	StorageTypeLocal StorageType = "local"
	StorageTypeS3    StorageType = "s3"
)

func (e *StorageType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StorageType(s)
	case string:
		*e = StorageType(s)
	default:
		return fmt.Errorf("unsupported scan type for StorageType: %T", src)
	}
	return nil
}

type NullStorageType struct {
	StorageType StorageType `json:"storage_type"`
	Valid       bool        `json:"valid"` // Valid is true if StorageType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStorageType) Scan(value interface{}) error {
	if value == nil {
		ns.StorageType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StorageType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStorageType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StorageType), nil
}

type BlockGallery struct {
	ID      uuid.UUID   `json:"id"`
	BlockID uuid.UUID   `json:"block_id"`
	Title   pgtype.Text `json:"title"`
}

type BlockHeader struct {
	ID         uuid.UUID   `json:"id"`
	BlockID    uuid.UUID   `json:"block_id"`
	Heading    string      `json:"heading"`
	Subheading pgtype.Text `json:"subheading"`
	Level      pgtype.Text `json:"level"`
}

type BlockHero struct {
	ID       uuid.UUID   `json:"id"`
	BlockID  uuid.UUID   `json:"block_id"`
	Title    string      `json:"title"`
	Subtitle pgtype.Text `json:"subtitle"`
	ImageID  pgtype.UUID `json:"image_id"`
	CtaText  pgtype.Text `json:"cta_text"`
	CtaUrl   pgtype.Text `json:"cta_url"`
}

type BlockRichtext struct {
	ID      uuid.UUID `json:"id"`
	BlockID uuid.UUID `json:"block_id"`
	Content string    `json:"content"`
}

type Blocks struct {
	ID         uuid.UUID `json:"id"`
	EntityType string    `json:"entity_type"`
	EntityID   uuid.UUID `json:"entity_id"`
	Type       string    `json:"type"`
	SortOrder  int32     `json:"sort_order"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type Blogs struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	Status          NullPageStatus     `json:"status"`
	Description     pgtype.Text        `json:"description"`
	ReadingTime     pgtype.Int4        `json:"reading_time"`
	IsFeatured      pgtype.Bool        `json:"is_featured"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type Media struct {
	ID               uuid.UUID   `json:"id"`
	Filename         string      `json:"filename"`
	OriginalFilename string      `json:"original_filename"`
	MimeType         string      `json:"mime_type"`
	SizeBytes        int64       `json:"size_bytes"`
	Width            pgtype.Int4 `json:"width"`
	Height           pgtype.Int4 `json:"height"`
	StorageType      StorageType `json:"storage_type"`
	StoragePath      string      `json:"storage_path"`
	S3Bucket         pgtype.Text `json:"s3_bucket"`
	S3Key            pgtype.Text `json:"s3_key"`
	S3Region         pgtype.Text `json:"s3_region"`
	// Deprecated - use variant-specific URLs instead
	Url pgtype.Text `json:"url"`
	// URL to original unprocessed file
	OriginalUrl pgtype.Text `json:"original_url"`
	// URL to large variant (1920px) - for hero sections
	LargeUrl pgtype.Text `json:"large_url"`
	// URL to medium variant (1024px) - for general content
	MediumUrl pgtype.Text `json:"medium_url"`
	// URL to thumbnail variant (300px) - for previews
	ThumbnailUrl  pgtype.Text        `json:"thumbnail_url"`
	OriginalPath  pgtype.Text        `json:"original_path"`
	LargePath     pgtype.Text        `json:"large_path"`
	MediumPath    pgtype.Text        `json:"medium_path"`
	ThumbnailPath pgtype.Text        `json:"thumbnail_path"`
	UploadedBy    uuid.UUID          `json:"uploaded_by"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
}

type MediaRelations struct {
	ID         uuid.UUID   `json:"id"`
	MediaID    uuid.UUID   `json:"media_id"`
	EntityType string      `json:"entity_type"`
	EntityID   uuid.UUID   `json:"entity_id"`
	SortOrder  pgtype.Int4 `json:"sort_order"`
	CreatedAt  time.Time   `json:"created_at"`
}

type Pages struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	Status          NullPageStatus     `json:"status"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type PasswordResetTokens struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt time.Time          `json:"created_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	IsUsed    pgtype.Bool        `json:"is_used"`
}

type Projects struct {
	ID              uuid.UUID          `json:"id"`
	Title           string             `json:"title"`
	Slug            string             `json:"slug"`
	Description     pgtype.Text        `json:"description"`
	ProjectDate     pgtype.Date        `json:"project_date"`
	Status          NullPageStatus     `json:"status"`
	ClientName      pgtype.Text        `json:"client_name"`
	ProjectYear     pgtype.Int4        `json:"project_year"`
	ProjectUrl      pgtype.Text        `json:"project_url"`
	Technologies    []byte             `json:"technologies"`
	ProjectStatus   NullProjectStatus  `json:"project_status"`
	FeaturedImageID pgtype.UUID        `json:"featured_image_id"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	PublishedAt     pgtype.Timestamptz `json:"published_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type Seo struct {
	ID              uuid.UUID   `json:"id"`
	EntityType      string      `json:"entity_type"`
	EntityID        uuid.UUID   `json:"entity_id"`
	MetaTitle       pgtype.Text `json:"meta_title"`
	MetaDescription pgtype.Text `json:"meta_description"`
	OgTitle         pgtype.Text `json:"og_title"`
	OgDescription   pgtype.Text `json:"og_description"`
	OgImageID       pgtype.UUID `json:"og_image_id"`
	CanonicalUrl    pgtype.Text `json:"canonical_url"`
	RobotsIndex     pgtype.Bool `json:"robots_index"`
	RobotsFollow    pgtype.Bool `json:"robots_follow"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
}

type Sessions struct {
	ID        uuid.UUID   `json:"id"`
	UserID    uuid.UUID   `json:"user_id"`
	Token     string      `json:"token"`
	ExpiresAt time.Time   `json:"expires_at"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	IpAddress *netip.Addr `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
	IsActive  pgtype.Bool `json:"is_active"`
}

type Users struct {
	ID           uuid.UUID `json:"id"`
	FirstName    string    `json:"first_name"`
	LastName     string    `json:"last_name"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}
