// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package media

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
  url, thumbnail_url, type, title, alt_text, mime_type, file_size, sort_order
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, url, thumbnail_url, type, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at
`

type CreateMediaParams struct {
	Url          string      `db:"url" json:"url"`
	ThumbnailUrl pgtype.Text `db:"thumbnail_url" json:"thumbnail_url"`
	Type         string      `db:"type" json:"type"`
	Title        pgtype.Text `db:"title" json:"title"`
	AltText      pgtype.Text `db:"alt_text" json:"alt_text"`
	MimeType     pgtype.Text `db:"mime_type" json:"mime_type"`
	FileSize     pgtype.Int4 `db:"file_size" json:"file_size"`
	SortOrder    int32       `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.Url,
		arg.ThumbnailUrl,
		arg.Type,
		arg.Title,
		arg.AltText,
		arg.MimeType,
		arg.FileSize,
		arg.SortOrder,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.ThumbnailUrl,
		&i.Type,
		&i.Title,
		&i.AltText,
		&i.MimeType,
		&i.FileSize,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media WHERE id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMedia, id)
	return err
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT id, url, thumbnail_url, type, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at FROM media WHERE id = $1
`

func (q *Queries) GetMediaByID(ctx context.Context, id pgtype.UUID) (Medium, error) {
	row := q.db.QueryRow(ctx, getMediaByID, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.ThumbnailUrl,
		&i.Type,
		&i.Title,
		&i.AltText,
		&i.MimeType,
		&i.FileSize,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMedia = `-- name: ListMedia :many
SELECT id, url, thumbnail_url, type, title, alt_text, mime_type, file_size, sort_order, created_at, updated_at FROM media ORDER BY sort_order ASC
`

func (q *Queries) ListMedia(ctx context.Context) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.ThumbnailUrl,
			&i.Type,
			&i.Title,
			&i.AltText,
			&i.MimeType,
			&i.FileSize,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMediaSortOrder = `-- name: UpdateMediaSortOrder :exec
UPDATE media SET sort_order = $1 WHERE id = $2
`

type UpdateMediaSortOrderParams struct {
	SortOrder int32       `db:"sort_order" json:"sort_order"`
	ID        pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateMediaSortOrder(ctx context.Context, arg UpdateMediaSortOrderParams) error {
	_, err := q.db.Exec(ctx, updateMediaSortOrder, arg.SortOrder, arg.ID)
	return err
}
