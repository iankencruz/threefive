# Taskfile.yml
version: "3"

dotenv: [".env", ".env.local"]

vars:
  BACKEND_DIR: ./backend
  FRONTEND_DIR: ./frontend
  BUILD_DIR: ./backend/bin
  BINARY_NAME: api
  GO_FILES: ./backend/cmd/api/main.go

  GO_GROUP: "Óòß GO"
  BUN_GROUP: "ÓùØ  BUN"

  # Database variables
  # GOOSE_MIGRATIONS_DIR: ./backend/sql/migrations/
  # GOOSE_DRIVER: postgres
  GOOSE_FLAGS: -s # Sequential ordering

# Hide task execution statements | true = hide, false = show (default)
# silent: true

tasks:
  default:
    desc: "Show available tasks"
    cmds:
      - task --list

  init:
    desc: "Initial project setup"
    cmds:
      - task: go:tidy
      - task: db:reset
      - task: db:up
      - task: sqlc

  podman:up:
    desc: "Run compose file"
    cmds:
      - echo "Starting compose containers"
      - podman compose up -d

  podman:down:
    desc: "Stop compose containers"
    cmds:
      - echo "Stopping compose containers"
      - podman compose down

  # =====================================
  # Database tasks (Goose)
  # =====================================

  db:create:
    desc: "Create new migration (use: task db:create -- migration_name)"
    cmds:
      - goose {{.GOOSE_FLAGS}} -dir {{.GOOSE_MIGRATION_DIR}} create {{.CLI_ARGS}} sql
    requires:
      vars: [GOOSE_MIGRATION_DIR]

  db:up:
    desc: "Applies database migrations. Use `task db:up` to apply all pending migrations or `task db:up -- <version>` to migrate to a specific version."
    cmds:
      - |
        {{if .CLI_ARGS}}
        goose up-to {{.CLI_ARGS}}
        {{else}}
        goose up
        {{end}}

  db:down:
    desc: "Rollback the last migration"
    cmds:
      - goose down

  
  db:status:
    desc: "Show migration status"
    cmds:
      - goose status

  db:reset:
    aliases: [db:res]
    desc: "Reset database (rollback all migrations)"
    prompt: "This will rollback all migrations. Are you sure?"
    cmds:
      - goose  reset


  db:version:
    aliases: [db-v]
    desc: "Show current migration version"
    cmds:
      - goose version

  db:fix:

    desc: "Fix sequential numbering of migration files"
    cmds:
      - goose fix


  # =====================================
  # SQLC tasks
  # =====================================

  sqlc:
    desc: "Generate Go code from SQL"
    dir: "{{.BACKEND_DIR}}"
    silent: true
    cmds:
      - sqlc generate
      - echo "sqlc generate completed."

  # =====================================
  # Backend tasks
  # =====================================

  go:tidy:
    desc: "Tidy Go modules"
    dir: "{{.BACKEND_DIR}}"
    cmds:
      - go mod tidy

  go:build:
    desc: "Build Go binary"
    dir: "{{.BACKEND_DIR}}"
    cmds:
      - go build -o ./tmp/main ./cmd/api/main.go
    sources:
      - "**/*.go"
      - go.mod
      - go.sum
    generates:
      - "{{.BUILD_DIR}}/{{.BINARY_NAME}}"

  go:
    desc: "Run backend with hot reload (Air)"
    dir: "{{.BACKEND_DIR}}"
    deps: [podman:up]
    cmds:
      - air


  bun:
    desc: "Run frontend development server"
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - bun --bun run dev --clearScreen false


  bun:install:
    desc: "Install frontend dependencies (use -- <package> to install specific)"
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - |
        if [ "{{.CLI_ARGS}}" != "<no value>" ]; then
          bun add {{.CLI_ARGS}}
        else
          bun install
        fi

  bun:build:
    desc: "Build frontend for production"
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - bun --bun run build

  bun:preview:
    desc: "Preview production build"
    dir: "{{.FRONTEND_DIR}}"
    deps: [bun:build]
    cmds:
      - bun --bun run preview


  bun:check:
    desc: "Run Biome check (lint + format)"
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - bunx biome check ./src

  bun:fix:
    desc: "Fix all issues (lint + format)"
    dir: "{{.FRONTEND_DIR}}"
    cmds:
      - bunx biome check --write ./src


  dev:
    desc: "Starts the Go backend (Air) and waits for it to be ready before starting the Bun frontend, with all logs visible."
    cmds:
      - |
        # 1. Enclose the logic in a subshell ( ). This creates a controlled Process Group (PGID).
        (
          # 2. Set the trap ONLY on EXIT. This is the most portable signal handler.
          # It triggers when the foreground process (task bun) exits (e.g., via Ctrl+C).
          trap '
            echo "CATCHING EXIT: Cleaning up background processes..."
            # 3. Kill the entire process group. This avoids shell variable issues.
            # -$$ targets the Process Group ID (PGID) of the current subshell.
            kill -TERM -- -$$ 2>/dev/null
            
            # 4. Explicitly exit 0 to ensure the cleanup step doesn''t return a status code (like 201 or 2).
            exit 0
          ' EXIT
          
          echo "Starting Go backend with Air..."
          task go > backend_startup.log 2>&1 &
          
          echo "Streaming backend logs..."
          tail -f backend_startup.log &
          
          # Wait for the backend to be ready
          echo "Waiting for backend to be ready (Server starting)..."
          while ! grep -q "üöÄ Server starting on http://" backend_startup.log; do
            sleep 1
          done
          
          echo "Backend is ready. Starting Bun frontend..."
          
          # Start the Bun frontend in the foreground.
          task bun
          
        )

  # =====================================
  # Build everything
  # =====================================


  # =====================================
  # Testing
  # test:
  #   desc: "Run all tests"
  #   cmds:
  #     - task: _test:backend
  #     - task: _test:frontend

  # =====================================
  # Utilities
  # =====================================

  clean:
    desc: "Clean build artifacts"
    cmds:
      - rm -rf {{.BACKEND_DIR}}/{{.BUILD_DIR}}
      - rm -rf {{.BACKEND_DIR}}/tmp
      - rm -rf {{.FRONTEND_DIR}}/build
      - rm -rf {{.FRONTEND_DIR}}/dist
      - rm -rf {{.FRONTEND_DIR}}/.svelte-kit
      - task: go:tidy

  health:
    desc: "Check if backend is running"
    cmds:
      - curl -f http://localhost:{{.PORT}}/health || echo "Backend not running"
