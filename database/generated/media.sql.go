// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: media.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateMediaRelationsParams struct {
	ID           pgtype.UUID
	MediaID      pgtype.UUID
	EntityType   string
	EntityID     pgtype.UUID
	RelationType string
	SortOrder    pgtype.Int4
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
WHERE deleted_at IS NULL
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMediaByType = `-- name: CountMediaByType :one
SELECT COUNT(*) FROM media
WHERE mime_type LIKE $1
  AND deleted_at IS NULL
`

func (q *Queries) CountMediaByType(ctx context.Context, mimeTypePattern string) (int64, error) {
	row := q.db.QueryRow(ctx, countMediaByType, mimeTypePattern)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMedia = `-- name: CreateMedia :one

INSERT INTO media (
    id,
    filename,
    original_filename,
    mime_type,
    file_size,
    width,
    height,
    duration,
    storage_type,
    s3_bucket,
    s3_region,
    original_key,
    large_key,
    medium_key,
    thumbnail_key,
    alt_text,
    uploaded_by,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    NOW(),
    NOW()
)
RETURNING id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at
`

type CreateMediaParams struct {
	ID               pgtype.UUID
	Filename         string
	OriginalFilename string
	MimeType         string
	FileSize         int64
	Width            pgtype.Int4
	Height           pgtype.Int4
	Duration         pgtype.Int4
	StorageType      string
	S3Bucket         pgtype.Text
	S3Region         pgtype.Text
	OriginalKey      pgtype.Text
	LargeKey         pgtype.Text
	MediumKey        pgtype.Text
	ThumbnailKey     pgtype.Text
	AltText          pgtype.Text
	UploadedBy       pgtype.UUID
}

// sql/queries/media.sql
func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Media, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.ID,
		arg.Filename,
		arg.OriginalFilename,
		arg.MimeType,
		arg.FileSize,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.StorageType,
		arg.S3Bucket,
		arg.S3Region,
		arg.OriginalKey,
		arg.LargeKey,
		arg.MediumKey,
		arg.ThumbnailKey,
		arg.AltText,
		arg.UploadedBy,
	)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createMediaRelation = `-- name: CreateMediaRelation :one

INSERT INTO media_relations (
    id,
    media_id,
    entity_type,
    entity_id,
    relation_type,
    sort_order
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING id, media_id, entity_type, entity_id, relation_type, sort_order, created_at
`

type CreateMediaRelationParams struct {
	ID           pgtype.UUID
	MediaID      pgtype.UUID
	EntityType   string
	EntityID     pgtype.UUID
	RelationType string
	SortOrder    pgtype.Int4
}

// Media Relations Queries
func (q *Queries) CreateMediaRelation(ctx context.Context, arg CreateMediaRelationParams) (MediaRelation, error) {
	row := q.db.QueryRow(ctx, createMediaRelation,
		arg.ID,
		arg.MediaID,
		arg.EntityType,
		arg.EntityID,
		arg.RelationType,
		arg.SortOrder,
	)
	var i MediaRelation
	err := row.Scan(
		&i.ID,
		&i.MediaID,
		&i.EntityType,
		&i.EntityID,
		&i.RelationType,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllMediaRelationsForEntity = `-- name: DeleteAllMediaRelationsForEntity :exec
DELETE FROM media_relations
WHERE entity_type = $1
  AND entity_id = $2
`

type DeleteAllMediaRelationsForEntityParams struct {
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) DeleteAllMediaRelationsForEntity(ctx context.Context, arg DeleteAllMediaRelationsForEntityParams) error {
	_, err := q.db.Exec(ctx, deleteAllMediaRelationsForEntity, arg.EntityType, arg.EntityID)
	return err
}

const deleteMediaRelation = `-- name: DeleteMediaRelation :exec
DELETE FROM media_relations
WHERE media_id = $1
  AND entity_type = $2
  AND entity_id = $3
`

type DeleteMediaRelationParams struct {
	MediaID    pgtype.UUID
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) DeleteMediaRelation(ctx context.Context, arg DeleteMediaRelationParams) error {
	_, err := q.db.Exec(ctx, deleteMediaRelation, arg.MediaID, arg.EntityType, arg.EntityID)
	return err
}

const getDeletedMedia = `-- name: GetDeletedMedia :many
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE deleted_at IS NOT NULL
ORDER BY deleted_at DESC
LIMIT $2
OFFSET $1
`

type GetDeletedMediaParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) GetDeletedMedia(ctx context.Context, arg GetDeletedMediaParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, getDeletedMedia, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeaturedMediaForEntity = `-- name: GetFeaturedMediaForEntity :one
SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
JOIN media_relations mr ON m.id = mr.media_id
WHERE mr.entity_type = $1
  AND mr.entity_id = $2
  AND mr.relation_type = 'featured'
  AND m.deleted_at IS NULL
LIMIT 1
`

type GetFeaturedMediaForEntityParams struct {
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) GetFeaturedMediaForEntity(ctx context.Context, arg GetFeaturedMediaForEntityParams) (Media, error) {
	row := q.db.QueryRow(ctx, getFeaturedMediaForEntity, arg.EntityType, arg.EntityID)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGalleryMediaForEntity = `-- name: GetGalleryMediaForEntity :many
SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
JOIN media_relations mr ON m.id = mr.media_id
WHERE mr.entity_type = $1
  AND mr.entity_id = $2
  AND mr.relation_type = 'gallery'
  AND m.deleted_at IS NULL
ORDER BY mr.sort_order ASC, m.created_at DESC
`

type GetGalleryMediaForEntityParams struct {
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) GetGalleryMediaForEntity(ctx context.Context, arg GetGalleryMediaForEntityParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, getGalleryMediaForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByFilename = `-- name: GetMediaByFilename :one
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE filename = $1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetMediaByFilename(ctx context.Context, filename string) (Media, error) {
	row := q.db.QueryRow(ctx, getMediaByFilename, filename)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE id = $1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetMediaByID(ctx context.Context, id pgtype.UUID) (Media, error) {
	row := q.db.QueryRow(ctx, getMediaByID, id)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMediaForEntity = `-- name: GetMediaForEntity :many
SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
JOIN media_relations mr ON m.id = mr.media_id
WHERE mr.entity_type = $1
  AND mr.entity_id = $2
  AND m.deleted_at IS NULL
ORDER BY mr.sort_order ASC, m.created_at DESC
`

type GetMediaForEntityParams struct {
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) GetMediaForEntity(ctx context.Context, arg GetMediaForEntityParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, getMediaForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaStats = `-- name: GetMediaStats :one

SELECT
    COUNT(*) as total_count,
    COALESCE(SUM(file_size), 0) as total_size,
    COUNT(*) FILTER (WHERE mime_type LIKE 'image/%') as image_count,
    COUNT(*) FILTER (WHERE mime_type LIKE 'video/%') as video_count,
    COUNT(*) FILTER (WHERE mime_type LIKE 'audio/%') as audio_count
FROM media
WHERE deleted_at IS NULL
`

type GetMediaStatsRow struct {
	TotalCount int64
	TotalSize  interface{}
	ImageCount int64
	VideoCount int64
	AudioCount int64
}

// Media Statistics
func (q *Queries) GetMediaStats(ctx context.Context) (GetMediaStatsRow, error) {
	row := q.db.QueryRow(ctx, getMediaStats)
	var i GetMediaStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.TotalSize,
		&i.ImageCount,
		&i.VideoCount,
		&i.AudioCount,
	)
	return i, err
}

const getMediaUsageByEntity = `-- name: GetMediaUsageByEntity :many
SELECT
    mr.entity_type,
    mr.entity_id,
    COUNT(*) as media_count
FROM media_relations mr
JOIN media m ON mr.media_id = m.id
WHERE m.deleted_at IS NULL
GROUP BY mr.entity_type, mr.entity_id
ORDER BY media_count DESC
LIMIT $1
`

type GetMediaUsageByEntityRow struct {
	EntityType string
	EntityID   pgtype.UUID
	MediaCount int64
}

func (q *Queries) GetMediaUsageByEntity(ctx context.Context, limitVal int32) ([]GetMediaUsageByEntityRow, error) {
	rows, err := q.db.Query(ctx, getMediaUsageByEntity, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMediaUsageByEntityRow
	for rows.Next() {
		var i GetMediaUsageByEntityRow
		if err := rows.Scan(&i.EntityType, &i.EntityID, &i.MediaCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedMedia = `-- name: GetOrphanedMedia :many
SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
LEFT JOIN media_relations mr ON m.id = mr.media_id
WHERE mr.id IS NULL
  AND m.deleted_at IS NULL
  AND m.created_at < NOW() - INTERVAL '1 day'
ORDER BY m.created_at DESC
`

func (q *Queries) GetOrphanedMedia(ctx context.Context) ([]Media, error) {
	rows, err := q.db.Query(ctx, getOrphanedMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteMedia = `-- name: HardDeleteMedia :exec
DELETE FROM media
WHERE id = $1
`

func (q *Queries) HardDeleteMedia(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteMedia, id)
	return err
}

const listMedia = `-- name: ListMedia :many
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET $1
`

type ListMediaParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) ListMedia(ctx context.Context, arg ListMediaParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, listMedia, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaByType = `-- name: ListMediaByType :many
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE mime_type LIKE $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type ListMediaByTypeParams struct {
	MimeTypePattern string
	OffsetVal       int32
	LimitVal        int32
}

func (q *Queries) ListMediaByType(ctx context.Context, arg ListMediaByTypeParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, listMediaByType, arg.MimeTypePattern, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaByUploader = `-- name: ListMediaByUploader :many
SELECT id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at FROM media
WHERE uploaded_by = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type ListMediaByUploaderParams struct {
	UploadedBy pgtype.UUID
	OffsetVal  int32
	LimitVal   int32
}

func (q *Queries) ListMediaByUploader(ctx context.Context, arg ListMediaByUploaderParams) ([]Media, error) {
	rows, err := q.db.Query(ctx, listMediaByUploader, arg.UploadedBy, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgeOldDeletedMedia = `-- name: PurgeOldDeletedMedia :exec
DELETE FROM media
WHERE deleted_at IS NOT NULL
  AND deleted_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) PurgeOldDeletedMedia(ctx context.Context) error {
	_, err := q.db.Exec(ctx, purgeOldDeletedMedia)
	return err
}

const reorderGalleryMedia = `-- name: ReorderGalleryMedia :exec
UPDATE media_relations
SET sort_order = $1
WHERE media_id = $2
  AND entity_type = $3
  AND entity_id = $4
  AND relation_type = 'gallery'
`

type ReorderGalleryMediaParams struct {
	SortOrder  pgtype.Int4
	MediaID    pgtype.UUID
	EntityType string
	EntityID   pgtype.UUID
}

func (q *Queries) ReorderGalleryMedia(ctx context.Context, arg ReorderGalleryMediaParams) error {
	_, err := q.db.Exec(ctx, reorderGalleryMedia,
		arg.SortOrder,
		arg.MediaID,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const restoreMedia = `-- name: RestoreMedia :exec
UPDATE media
SET
    deleted_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RestoreMedia(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, restoreMedia, id)
	return err
}

const softDeleteMedia = `-- name: SoftDeleteMedia :exec
UPDATE media
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteMedia(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteMedia, id)
	return err
}

const updateMedia = `-- name: UpdateMedia :one
UPDATE media
SET
    alt_text = COALESCE($1, alt_text),
    updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
RETURNING id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at
`

type UpdateMediaParams struct {
	AltText pgtype.Text
	ID      pgtype.UUID
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (Media, error) {
	row := q.db.QueryRow(ctx, updateMedia, arg.AltText, arg.ID)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateMediaAltText = `-- name: UpdateMediaAltText :one
UPDATE media
SET
    alt_text = $1,
    updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
RETURNING id, filename, original_filename, mime_type, file_size, width, height, duration, storage_type, s3_bucket, s3_region, original_key, large_key, medium_key, thumbnail_key, alt_text, uploaded_by, created_at, updated_at, deleted_at
`

type UpdateMediaAltTextParams struct {
	AltText pgtype.Text
	ID      pgtype.UUID
}

func (q *Queries) UpdateMediaAltText(ctx context.Context, arg UpdateMediaAltTextParams) (Media, error) {
	row := q.db.QueryRow(ctx, updateMediaAltText, arg.AltText, arg.ID)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
