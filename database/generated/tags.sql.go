// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkTagSlugExists = `-- name: CheckTagSlugExists :one
SELECT EXISTS(
    SELECT 1 FROM tags 
    WHERE slug = $1 
      AND id != $2
)
`

type CheckTagSlugExistsParams struct {
	Slug  string
	TagID pgtype.UUID
}

func (q *Queries) CheckTagSlugExists(ctx context.Context, arg CheckTagSlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkTagSlugExists, arg.Slug, arg.TagID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTag = `-- name: CreateTag :one

INSERT INTO tags (
    id,
    name,
    slug,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    NOW(),
    NOW()
)
RETURNING id, name, slug, created_at, updated_at
`

type CreateTagParams struct {
	ID   pgtype.UUID
	Name string
	Slug string
}

// Tags CRUD Operations
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.ID, arg.Name, arg.Slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const findOrCreateTag = `-- name: FindOrCreateTag :one
INSERT INTO tags (id, name, slug, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
ON CONFLICT (slug) DO UPDATE SET updated_at = NOW()
RETURNING id, name, slug, created_at, updated_at
`

type FindOrCreateTagParams struct {
	ID   pgtype.UUID
	Name string
	Slug string
}

func (q *Queries) FindOrCreateTag(ctx context.Context, arg FindOrCreateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, findOrCreateTag, arg.ID, arg.Name, arg.Slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMostUsedTags = `-- name: GetMostUsedTags :many
SELECT 
    t.id, t.name, t.slug, t.created_at, t.updated_at,
    COUNT(pt.project_id) as usage_count
FROM tags t
LEFT JOIN project_tags pt ON t.id = pt.tag_id
GROUP BY t.id
ORDER BY usage_count DESC, t.name ASC
LIMIT $1
`

type GetMostUsedTagsRow struct {
	ID         pgtype.UUID
	Name       string
	Slug       string
	CreatedAt  time.Time
	UpdatedAt  time.Time
	UsageCount int64
}

func (q *Queries) GetMostUsedTags(ctx context.Context, limitVal int32) ([]GetMostUsedTagsRow, error) {
	rows, err := q.db.Query(ctx, getMostUsedTags, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostUsedTagsRow
	for rows.Next() {
		var i GetMostUsedTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, slug, created_at, updated_at FROM tags
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTagByID(ctx context.Context, id pgtype.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagBySlug = `-- name: GetTagBySlug :one
SELECT id, name, slug, created_at, updated_at FROM tags
WHERE slug = $1
LIMIT 1
`

func (q *Queries) GetTagBySlug(ctx context.Context, slug string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagBySlug, slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagIDBySlug = `-- name: GetTagIDBySlug :one
SELECT id FROM tags
WHERE slug = $1
LIMIT 1
`

func (q *Queries) GetTagIDBySlug(ctx context.Context, slug string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getTagIDBySlug, slug)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getTagUsageCount = `-- name: GetTagUsageCount :one

SELECT COUNT(*) FROM project_tags
WHERE tag_id = $1
`

// Tag Usage Statistics
func (q *Queries) GetTagUsageCount(ctx context.Context, tagID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getTagUsageCount, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTagsByIDs = `-- name: GetTagsByIDs :many

SELECT id, name, slug, created_at, updated_at FROM tags
WHERE id = ANY($1::uuid[])
ORDER BY name ASC
`

// Batch Operations
func (q *Queries) GetTagsByIDs(ctx context.Context, tagIds []pgtype.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getTagsByIDs, tagIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnusedTags = `-- name: GetUnusedTags :many
SELECT t.id, t.name, t.slug, t.created_at, t.updated_at FROM tags t
LEFT JOIN project_tags pt ON t.id = pt.tag_id
WHERE pt.tag_id IS NULL
ORDER BY t.name ASC
`

func (q *Queries) GetUnusedTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getUnusedTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTags = `-- name: ListAllTags :many
SELECT id, name, slug, created_at, updated_at FROM tags
ORDER BY name ASC
`

func (q *Queries) ListAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, slug, created_at, updated_at FROM tags
ORDER BY name ASC
LIMIT $2
OFFSET $1
`

type ListTagsParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTags = `-- name: SearchTags :many
SELECT id, name, slug, created_at, updated_at FROM tags
WHERE name ILIKE $1
ORDER BY name ASC
LIMIT $3
OFFSET $2
`

type SearchTagsParams struct {
	SearchTerm string
	OffsetVal  int32
	LimitVal   int32
}

func (q *Queries) SearchTags(ctx context.Context, arg SearchTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, searchTags, arg.SearchTerm, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags SET
    name = COALESCE($1, name),
    slug = COALESCE($2, slug),
    updated_at = NOW()
WHERE id = $3
RETURNING id, name, slug, created_at, updated_at
`

type UpdateTagParams struct {
	Name pgtype.Text
	Slug pgtype.Text
	ID   pgtype.UUID
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.Name, arg.Slug, arg.ID)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
