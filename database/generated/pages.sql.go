// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pages.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFeaturedProject = `-- name: AddFeaturedProject :one

INSERT INTO page_featured_projects (page_id, project_id, display_order)
VALUES ($1, $2, $3)
ON CONFLICT (page_id, project_id) 
DO UPDATE SET display_order = EXCLUDED.display_order
RETURNING page_id, project_id, display_order, created_at
`

type AddFeaturedProjectParams struct {
	PageID       pgtype.UUID
	ProjectID    pgtype.UUID
	DisplayOrder int32
}

// Featured Projects for About Page
func (q *Queries) AddFeaturedProject(ctx context.Context, arg AddFeaturedProjectParams) (PageFeaturedProject, error) {
	row := q.db.QueryRow(ctx, addFeaturedProject, arg.PageID, arg.ProjectID, arg.DisplayOrder)
	var i PageFeaturedProject
	err := row.Scan(
		&i.PageID,
		&i.ProjectID,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const clearFeaturedProjects = `-- name: ClearFeaturedProjects :exec
DELETE FROM page_featured_projects
WHERE page_id = $1
`

func (q *Queries) ClearFeaturedProjects(ctx context.Context, pageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearFeaturedProjects, pageID)
	return err
}

const countFeaturedProjects = `-- name: CountFeaturedProjects :one
SELECT COUNT(*) FROM page_featured_projects
WHERE page_id = $1
`

func (q *Queries) CountFeaturedProjects(ctx context.Context, pageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFeaturedProjects, pageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFeaturedProjects = `-- name: GetFeaturedProjects :many
SELECT 
    p.id,
    p.title,
    p.slug,
    p.description,
    p.featured_image_id,
    pfp.display_order
FROM page_featured_projects pfp
JOIN projects p ON pfp.project_id = p.id
WHERE pfp.page_id = $1 
  AND p.deleted_at IS NULL
  AND p.status = 'published'
ORDER BY pfp.display_order ASC
`

type GetFeaturedProjectsRow struct {
	ID              pgtype.UUID
	Title           string
	Slug            string
	Description     pgtype.Text
	FeaturedImageID pgtype.UUID
	DisplayOrder    int32
}

func (q *Queries) GetFeaturedProjects(ctx context.Context, pageID pgtype.UUID) ([]GetFeaturedProjectsRow, error) {
	rows, err := q.db.Query(ctx, getFeaturedProjects, pageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeaturedProjectsRow
	for rows.Next() {
		var i GetFeaturedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.FeaturedImageID,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageBySlug = `-- name: GetPageBySlug :one

SELECT id, title, slug, page_type, hero_media_id, header, sub_header, content, content_image_id, cta_text, cta_link, email, social_links, created_at, updated_at, deleted_at FROM pages
WHERE slug = $1 AND deleted_at IS NULL
LIMIT 1
`

// Basic page queries
func (q *Queries) GetPageBySlug(ctx context.Context, slug string) (Page, error) {
	row := q.db.QueryRow(ctx, getPageBySlug, slug)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.PageType,
		&i.HeroMediaID,
		&i.Header,
		&i.SubHeader,
		&i.Content,
		&i.ContentImageID,
		&i.CtaText,
		&i.CtaLink,
		&i.Email,
		&i.SocialLinks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPageByType = `-- name: GetPageByType :one
SELECT id, title, slug, page_type, hero_media_id, header, sub_header, content, content_image_id, cta_text, cta_link, email, social_links, created_at, updated_at, deleted_at FROM pages
WHERE page_type = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetPageByType(ctx context.Context, pageType string) (Page, error) {
	row := q.db.QueryRow(ctx, getPageByType, pageType)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.PageType,
		&i.HeroMediaID,
		&i.Header,
		&i.SubHeader,
		&i.Content,
		&i.ContentImageID,
		&i.CtaText,
		&i.CtaLink,
		&i.Email,
		&i.SocialLinks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listPages = `-- name: ListPages :many
SELECT id, title, slug, page_type, hero_media_id, header, sub_header, content, content_image_id, cta_text, cta_link, email, social_links, created_at, updated_at, deleted_at FROM pages
WHERE deleted_at IS NULL
ORDER BY page_type ASC
`

func (q *Queries) ListPages(ctx context.Context) ([]Page, error) {
	rows, err := q.db.Query(ctx, listPages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.PageType,
			&i.HeroMediaID,
			&i.Header,
			&i.SubHeader,
			&i.Content,
			&i.ContentImageID,
			&i.CtaText,
			&i.CtaLink,
			&i.Email,
			&i.SocialLinks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFeaturedProject = `-- name: RemoveFeaturedProject :exec
DELETE FROM page_featured_projects
WHERE page_id = $1 AND project_id = $2
`

type RemoveFeaturedProjectParams struct {
	PageID    pgtype.UUID
	ProjectID pgtype.UUID
}

func (q *Queries) RemoveFeaturedProject(ctx context.Context, arg RemoveFeaturedProjectParams) error {
	_, err := q.db.Exec(ctx, removeFeaturedProject, arg.PageID, arg.ProjectID)
	return err
}

const updatePage = `-- name: UpdatePage :one
UPDATE pages SET
    title = COALESCE($1, title),
    slug = COALESCE($2, slug),
    hero_media_id = COALESCE($3, hero_media_id),
    header = COALESCE($4, header),
    sub_header = COALESCE($5, sub_header),
    content = COALESCE($6, content),
    content_image_id = COALESCE($7, content_image_id),
    cta_text = COALESCE($8, cta_text),
    cta_link = COALESCE($9, cta_link),
    email = COALESCE($10, email),
    social_links = COALESCE($11, social_links),
    updated_at = NOW()
WHERE id = $12
RETURNING id, title, slug, page_type, hero_media_id, header, sub_header, content, content_image_id, cta_text, cta_link, email, social_links, created_at, updated_at, deleted_at
`

type UpdatePageParams struct {
	Title          pgtype.Text
	Slug           pgtype.Text
	HeroMediaID    pgtype.UUID
	Header         pgtype.Text
	SubHeader      pgtype.Text
	Content        pgtype.Text
	ContentImageID pgtype.UUID
	CtaText        pgtype.Text
	CtaLink        pgtype.Text
	Email          pgtype.Text
	SocialLinks    []byte
	ID             pgtype.UUID
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) (Page, error) {
	row := q.db.QueryRow(ctx, updatePage,
		arg.Title,
		arg.Slug,
		arg.HeroMediaID,
		arg.Header,
		arg.SubHeader,
		arg.Content,
		arg.ContentImageID,
		arg.CtaText,
		arg.CtaLink,
		arg.Email,
		arg.SocialLinks,
		arg.ID,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.PageType,
		&i.HeroMediaID,
		&i.Header,
		&i.SubHeader,
		&i.Content,
		&i.ContentImageID,
		&i.CtaText,
		&i.CtaLink,
		&i.Email,
		&i.SocialLinks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
