// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectTag = `-- name: AddProjectTag :one

INSERT INTO project_tags (project_id, tag_id, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (project_id, tag_id) DO NOTHING
RETURNING project_id, tag_id, created_at
`

type AddProjectTagParams struct {
	ProjectID pgtype.UUID
	TagID     pgtype.UUID
}

// Project Tags Operations
func (q *Queries) AddProjectTag(ctx context.Context, arg AddProjectTagParams) (ProjectTag, error) {
	row := q.db.QueryRow(ctx, addProjectTag, arg.ProjectID, arg.TagID)
	var i ProjectTag
	err := row.Scan(&i.ProjectID, &i.TagID, &i.CreatedAt)
	return i, err
}

const checkProjectSlugExists = `-- name: CheckProjectSlugExists :one
SELECT EXISTS(
    SELECT 1 FROM projects 
    WHERE slug = $1 
      AND id != $2
      AND deleted_at IS NULL
)
`

type CheckProjectSlugExistsParams struct {
	Slug      string
	ProjectID pgtype.UUID
}

func (q *Queries) CheckProjectSlugExists(ctx context.Context, arg CheckProjectSlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectSlugExists, arg.Slug, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clearProjectTags = `-- name: ClearProjectTags :exec
DELETE FROM project_tags
WHERE project_id = $1
`

func (q *Queries) ClearProjectTags(ctx context.Context, projectID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearProjectTags, projectID)
	return err
}

const countProjectGalleryImages = `-- name: CountProjectGalleryImages :one
SELECT COUNT(*) FROM media_relations
WHERE entity_type = 'project'
  AND entity_id = $1
  AND relation_type = 'gallery'
`

func (q *Queries) CountProjectGalleryImages(ctx context.Context, projectID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectGalleryImages, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectTags = `-- name: CountProjectTags :one
SELECT COUNT(*) FROM project_tags
WHERE project_id = $1
`

func (q *Queries) CountProjectTags(ctx context.Context, projectID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectTags, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjects = `-- name: CountProjects :one
SELECT COUNT(*) FROM projects
WHERE deleted_at IS NULL
`

func (q *Queries) CountProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedProjects = `-- name: CountPublishedProjects :one
SELECT COUNT(*) FROM projects
WHERE status = 'published' 
  AND deleted_at IS NULL
  AND published_at IS NOT NULL
`

func (q *Queries) CountPublishedProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishedProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :one

INSERT INTO projects (
    id,
    title,
    slug,
    description,
    project_date,
    status,
    client_name,
    project_year,
    project_url,
    project_status,
    featured_image_id,
    author_id,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    NOW(),
    NOW()
)
RETURNING id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at
`

type CreateProjectParams struct {
	ID              pgtype.UUID
	Title           string
	Slug            string
	Description     pgtype.Text
	ProjectDate     pgtype.Date
	Status          pgtype.Text
	ClientName      pgtype.Text
	ProjectYear     pgtype.Int4
	ProjectUrl      pgtype.Text
	ProjectStatus   pgtype.Text
	FeaturedImageID pgtype.UUID
	AuthorID        pgtype.UUID
}

// Projects CRUD Operations
func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.ID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.ProjectDate,
		arg.Status,
		arg.ClientName,
		arg.ProjectYear,
		arg.ProjectUrl,
		arg.ProjectStatus,
		arg.FeaturedImageID,
		arg.AuthorID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetProjectByID(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectBySlug = `-- name: GetProjectBySlug :one
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE slug = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetProjectBySlug(ctx context.Context, slug string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectFeaturedImage = `-- name: GetProjectFeaturedImage :one
SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
WHERE m.id = $1
  AND m.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetProjectFeaturedImage(ctx context.Context, featuredImageID pgtype.UUID) (Media, error) {
	row := q.db.QueryRow(ctx, getProjectFeaturedImage, featuredImageID)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.OriginalFilename,
		&i.MimeType,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.StorageType,
		&i.S3Bucket,
		&i.S3Region,
		&i.OriginalKey,
		&i.LargeKey,
		&i.MediumKey,
		&i.ThumbnailKey,
		&i.AltText,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectGallery = `-- name: GetProjectGallery :many

SELECT m.id, m.filename, m.original_filename, m.mime_type, m.file_size, m.width, m.height, m.duration, m.storage_type, m.s3_bucket, m.s3_region, m.original_key, m.large_key, m.medium_key, m.thumbnail_key, m.alt_text, m.uploaded_by, m.created_at, m.updated_at, m.deleted_at FROM media m
JOIN media_relations mr ON m.id = mr.media_id
WHERE mr.entity_type = 'project'
  AND mr.entity_id = $1
  AND mr.relation_type = 'gallery'
  AND m.deleted_at IS NULL
ORDER BY mr.sort_order ASC, m.created_at DESC
`

// Project Gallery Operations (via media_relations)
func (q *Queries) GetProjectGallery(ctx context.Context, projectID pgtype.UUID) ([]Media, error) {
	rows, err := q.db.Query(ctx, getProjectGallery, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.OriginalFilename,
			&i.MimeType,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.StorageType,
			&i.S3Bucket,
			&i.S3Region,
			&i.OriginalKey,
			&i.LargeKey,
			&i.MediumKey,
			&i.ThumbnailKey,
			&i.AltText,
			&i.UploadedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIDBySlug = `-- name: GetProjectIDBySlug :one
SELECT id FROM projects
WHERE slug = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetProjectIDBySlug(ctx context.Context, slug string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getProjectIDBySlug, slug)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getProjectTags = `-- name: GetProjectTags :many
SELECT t.id, t.name, t.slug, t.created_at, t.updated_at FROM tags t
JOIN project_tags pt ON t.id = pt.tag_id
WHERE pt.project_id = $1
ORDER BY t.name ASC
`

func (q *Queries) GetProjectTags(ctx context.Context, projectID pgtype.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getProjectTags, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByStatus = `-- name: GetProjectsByStatus :many
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE status = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type GetProjectsByStatusParams struct {
	Status    pgtype.Text
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) GetProjectsByStatus(ctx context.Context, arg GetProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByStatus, arg.Status, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByTag = `-- name: GetProjectsByTag :many
SELECT p.id, p.title, p.slug, p.description, p.project_date, p.status, p.client_name, p.project_year, p.project_url, p.project_status, p.featured_image_id, p.author_id, p.created_at, p.updated_at, p.published_at, p.deleted_at FROM projects p
JOIN project_tags pt ON p.id = pt.project_id
WHERE pt.tag_id = $1
  AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $3
OFFSET $2
`

type GetProjectsByTagParams struct {
	TagID     pgtype.UUID
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) GetProjectsByTag(ctx context.Context, arg GetProjectsByTagParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByTag, arg.TagID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByYear = `-- name: GetProjectsByYear :many
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE project_year = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetProjectsByYear(ctx context.Context, projectYear pgtype.Int4) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByYear, projectYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentProjects = `-- name: GetRecentProjects :many
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentProjects(ctx context.Context, limitVal int32) ([]Project, error) {
	rows, err := q.db.Query(ctx, getRecentProjects, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteProject = `-- name: HardDeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) HardDeleteProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteProject, id)
	return err
}

const listProjects = `-- name: ListProjects :many
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET $1
`

type ListProjectsParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedProjects = `-- name: ListPublishedProjects :many
SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE status = 'published' 
  AND deleted_at IS NULL
  AND published_at IS NOT NULL
ORDER BY published_at DESC
LIMIT $2
OFFSET $1
`

type ListPublishedProjectsParams struct {
	OffsetVal int32
	LimitVal  int32
}

func (q *Queries) ListPublishedProjects(ctx context.Context, arg ListPublishedProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listPublishedProjects, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishProject = `-- name: PublishProject :one
UPDATE projects SET
    status = 'published',
    published_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at
`

func (q *Queries) PublishProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, publishProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const removeProjectTag = `-- name: RemoveProjectTag :exec
DELETE FROM project_tags
WHERE project_id = $1 AND tag_id = $2
`

type RemoveProjectTagParams struct {
	ProjectID pgtype.UUID
	TagID     pgtype.UUID
}

func (q *Queries) RemoveProjectTag(ctx context.Context, arg RemoveProjectTagParams) error {
	_, err := q.db.Exec(ctx, removeProjectTag, arg.ProjectID, arg.TagID)
	return err
}

const restoreProject = `-- name: RestoreProject :exec
UPDATE projects
SET
    deleted_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RestoreProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, restoreProject, id)
	return err
}

const searchProjects = `-- name: SearchProjects :many

SELECT id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at FROM projects
WHERE deleted_at IS NULL
  AND (
    title ILIKE $1
    OR description ILIKE $1
    OR client_name ILIKE $1
  )
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type SearchProjectsParams struct {
	SearchTerm string
	OffsetVal  int32
	LimitVal   int32
}

// Search and Filter Operations
func (q *Queries) SearchProjects(ctx context.Context, arg SearchProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, searchProjects, arg.SearchTerm, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.ProjectDate,
			&i.Status,
			&i.ClientName,
			&i.ProjectYear,
			&i.ProjectUrl,
			&i.ProjectStatus,
			&i.FeaturedImageID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProject = `-- name: SoftDeleteProject :exec
UPDATE projects
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProject, id)
	return err
}

const unpublishProject = `-- name: UnpublishProject :one
UPDATE projects SET
    status = 'draft',
    published_at = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at
`

func (q *Queries) UnpublishProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, unpublishProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET
    title = COALESCE($1, title),
    slug = COALESCE($2, slug),
    description = COALESCE($3, description),
    project_date = COALESCE($4, project_date),
    status = COALESCE($5, status),
    client_name = COALESCE($6, client_name),
    project_year = COALESCE($7, project_year),
    project_url = COALESCE($8, project_url),
    project_status = COALESCE($9, project_status),
    featured_image_id = COALESCE($10, featured_image_id),
    updated_at = NOW()
WHERE id = $11
RETURNING id, title, slug, description, project_date, status, client_name, project_year, project_url, project_status, featured_image_id, author_id, created_at, updated_at, published_at, deleted_at
`

type UpdateProjectParams struct {
	Title           pgtype.Text
	Slug            pgtype.Text
	Description     pgtype.Text
	ProjectDate     pgtype.Date
	Status          pgtype.Text
	ClientName      pgtype.Text
	ProjectYear     pgtype.Int4
	ProjectUrl      pgtype.Text
	ProjectStatus   pgtype.Text
	FeaturedImageID pgtype.UUID
	ID              pgtype.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.ProjectDate,
		arg.Status,
		arg.ClientName,
		arg.ProjectYear,
		arg.ProjectUrl,
		arg.ProjectStatus,
		arg.FeaturedImageID,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.ProjectDate,
		&i.Status,
		&i.ClientName,
		&i.ProjectYear,
		&i.ProjectUrl,
		&i.ProjectStatus,
		&i.FeaturedImageID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}
